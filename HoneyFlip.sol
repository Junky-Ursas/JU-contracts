// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./BaseGameContract.sol";

/// @title HoneyFlip
/// @dev Contract for a flipping game where players can wager tokens and win based on random entropy.
contract HoneyFlipProxy is BaseGameContractProxy {

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @dev Calculates the payout based on the wager and winning probability.
    /// @param wager The amount wagered by the player
    /// @param probability The probability of winning
    /// @return The calculated payout amount
    function calculatePayout(uint256 wager, uint8 probability) internal view returns (uint256) {
        // Calculate the house edge percentage
        uint256 houseEdgePercent = 100 - houseEdge;
        // Adjust the wager based on the house edge percentage
        uint256 adjustWager = wager * houseEdgePercent / 100;
        // Calculate the payout based on the adjusted wager and probability
        return adjustWager * 100 / probability;
    }

    /// @dev Modifier to ensure that the maximum payout does not exceed the treasury balance.
    /// @param wager The amount wagered by the player
    /// @param count The number of game iterations
    /// @param probability The probability of winning
    /// @param token The address of the token used for the wager
    modifier maxPayoutNotExceeded(uint256 wager, uint8 count, uint8 probability, address token) {
        // Calculate the maximum payout based on the wager, count, probability, and house edge
        require(wager * count * (100 / probability) * (100 - houseEdge) / 100 <= treasury.getBalance(token) / 20, "Max payout exceeded");
        _;
    }

    /// @dev Starts a new game with the specified parameters.
    /// @param config The parameters for the game
    function playHoneyflip(GameConfig memory config) 
        external payable maxPayoutNotExceeded(config.wager, config.count, config.extra, config.token) nonReentrant 
    {
        // Check that the winning probability is valid
        require(config.extra > 0 && config.extra < 70, "Invalid probability");

        uint256 fee = entropy.getFee(entropyProvider);
        // Check that the fee is sufficient
        require(msg.value >= fee, "Insufficient fee");
        // Check that the bet amount is above the minimum required
        require(config.wager * config.count >= minAmount, "Bet amount is below the minimum required");
        // Check if the count is valid
        require(config.count < 70, "Invalid count");


        if (config.token == address(0)) {
            // If the token is Ether
            require(msg.value > fee, "Bet amount too low");
            uint256 netAmount = msg.value - fee;
            require(netAmount >= config.wager * config.count, "Bet amount too low");
        } else {
            // If the token is an ERC20 token
            IERC20 tokenContract = IERC20(config.token);
            uint256 allowance = tokenContract.allowance(msg.sender, address(this));
            require(allowance >= config.wager * config.count, "Allowance too low");
            tokenContract.transferFrom(msg.sender, address(this), config.wager * config.count);
        }

        // Request the entropy contract to generate a random number
        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(entropyProvider, config.userRandomNumber);

        // Store the game configuration in the games mapping
        games[sequenceNumber] = abi.encode(config);

        // Emit the GameStarted event
        emit GameStarted(sequenceNumber, msg.sender, config.wager, config.count, config.token, config.userRandomNumber);
        // Notify the treasury contract of the game start
        treasury.notifyGameStarted(sequenceNumber, msg.sender, config.wager, config.count, config.token);
    }

    /// @dev Callback function called by the entropy contract with the random number.
    /// @param sequenceNumber The sequence number of the game
    /// @param randomNumber The random number generated by the entropy contract
    function entropyCallback(uint64 sequenceNumber, address, bytes32 randomNumber) internal override {
        // Decode the game configuration from the games mapping
        GameConfig memory game = abi.decode(games[sequenceNumber], (GameConfig));
        // Initialize the flags struct
        Flags memory flags;
        flags.totalPayout = 0;
        flags.wonCount = 0;
        flags.playedCount = 0;
        flags.initialRandomNumber = randomNumber;
        flags.previousMultiplier = 0;

        for (uint8 i = 0; i < game.count && flags.playedCount < 100; i++) {
            // Check if the player won based on the random number
            bool won = (uint256(randomNumber) % 100) < game.extra;
            // Calculate the payout if the player won
            uint256 payout = 0;
            if (won) {
                payout = calculatePayout(game.wager, game.extra);
                flags.totalPayout += payout;
                flags.wonCount++;
            }
            flags.playedCount++;

            // Shift the random number to the right by 2 bits
            randomNumber >>= 2;
        }

        // Calculate the unplayed wager amount
        uint256 unplayedWager = game.wager * (game.count - flags.playedCount);
        // Calculate the total refund amount
        uint256 totalRefund = (flags.totalPayout + unplayedWager);

        // Request a payout from the treasury contract if there is a non-zero refund amount
        if (totalRefund > 0) {
            treasury.requestPayout(game.player, totalRefund, game.token);
        }

        // Handle deposits of wagers in either Ether or ERC20 tokens
        uint256 totalWager = game.wager * game.count;
        if (game.token == address(0)) {
            // If the token is Ether
            treasury.deposit{value: totalWager}(totalWager);
        } else {
            // If the token is an ERC20 token
            IERC20 tokenContract = IERC20(game.token);
            tokenContract.approve(address(treasury), totalWager);
            treasury.transferFrom(game.token, address(this), address(treasury), totalWager);
        }

        // Emit the GameResult event
        emit GameResult(game.player, totalRefund, flags.initialRandomNumber, flags.wonCount, flags.playedCount, game.token);
        // Notify the treasury contract of the game result
        treasury.notifyGameResult(sequenceNumber, totalRefund, flags.initialRandomNumber, flags.wonCount, flags.playedCount, game.extra);
    }
}

