// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./BaseGameContract.sol";

/// @title JunkySlots
/// @dev Contract for a slots game where players can wager tokens and win based on random entropy.
contract JunkySlotsProxy is BaseGameContractProxy {

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @dev Modifier to ensure that the maximum payout does not exceed the treasury balance.
    /// @param wager The amount wagered by the player
    /// @param count The number of game iterations
    /// @param token The address of the token used for the wager
    modifier maxPayoutNotExceeded(uint256 wager, uint8 count, address token) {
        // Check if the maximum payout exceeds the treasury balance
        require(wager * count <= treasury.getBalance(token) / 100, "Max payout exceeded");
        _;
    }

    /// @dev Starts a new game with the specified parameters.
    /// @param config The parameters for the game
    function playJunkyslots(GameConfig memory config) 
        external payable maxPayoutNotExceeded(config.wager, config.count, config.token) nonReentrant 
    {
        // Get the fee for the entropy provider
        uint256 fee = entropy.getFee(entropyProvider);
        // Check if the sent value is sufficient to cover the fee
        require(msg.value >= fee, "Insufficient fee");
        // Check if the bet amount is above the minimum required
        require(config.wager * config.count >= minAmount, "Bet amount is below the minimum required");
        // Check if the count is valid
        require(config.count < 70, "Invalid count");
        // Handle the deposit of wagers
        if (config.token == address(0)) {
            // If the token is Ether
            require(msg.value > fee, "Bet amount too low");
            uint256 netAmount = msg.value - fee;
            require(netAmount >= config.wager * config.count, "Bet amount too low");
        } else {
            // If the token is an ERC20 token
            IERC20 tokenContract = IERC20(config.token);
            uint256 allowance = tokenContract.allowance(msg.sender, address(this));
            require(allowance >= config.wager * config.count, "Allowance too low");
            tokenContract.transferFrom(msg.sender, address(this), config.wager * config.count);
        }
        // Request entropy with a callback and store the game configuration
        uint64 sequenceNumber = entropy.requestWithCallback{value: fee}(entropyProvider, config.userRandomNumber);
        games[sequenceNumber] = abi.encode(config);
        // Emit events and notify the treasury contract about the game start
        emit GameStarted(sequenceNumber, msg.sender, config.wager, config.count, config.token, config.userRandomNumber);
        treasury.notifyGameStarted(sequenceNumber, msg.sender, config.wager, config.count, config.token);
    }

    /// @dev Callback function called by the entropy contract with the random number.
    /// @param sequenceNumber The sequence number of the game
    /// @param randomNumber The random number generated by the entropy contract
    function entropyCallback(uint64 sequenceNumber, address, bytes32 randomNumber) internal override {
        // Decode the game configuration
        GameConfig memory game = abi.decode(games[sequenceNumber], (GameConfig));
        // Initialize flags for the game
        Flags memory flags;
        flags.totalPayout = 0;
        flags.wonCount = 0;
        flags.playedCount = 0;
        flags.initialRandomNumber = randomNumber;
        flags.previousMultiplier = 0;

        // Iterate over the game iterations
        for (uint8 i = 0; i < game.count && flags.playedCount < 69; i++) {
            // Generate the slot symbols based on the random number
            Symbols memory symbols = Symbols(
                uint8(uint256(randomNumber) % 7),
                uint8((uint256(randomNumber) / 7) % 7),
                uint8((uint256(randomNumber) / 49) % 7)
            );

            // Determine the multiplier based on the slot symbols
            uint256 currentMultiplier = getMultiplier(symbols);

            // Apply special conditions
            if (flags.previousMultiplier == 6 && currentMultiplier == 9) {
                currentMultiplier = 69;
            } else if (flags.previousMultiplier == 9 && currentMultiplier == 9) {
                currentMultiplier = 99;
            } else if (flags.previousMultiplier == 3 && currentMultiplier == 6) {
                currentMultiplier = 36;
            }

            // Update previousMultiplier for the next iteration
            flags.previousMultiplier = currentMultiplier;
            // Update the total payout
            flags.totalPayout += game.wager * currentMultiplier;
            flags.playedCount++;
            // Shift the random number for the next iteration
            randomNumber >>= 3;
        }

        // Calculate the unplayed wager
        uint256 unplayedWager = game.wager * (game.count - flags.playedCount);
        // Calculate the total refund
        uint256 totalRefund = flags.totalPayout + unplayedWager;

        // Request payout from the treasury if the total refund is non-zero
        if (totalRefund > 0) {
            treasury.requestPayout(game.player, totalRefund, game.token);
        }

        uint256 totalWager = game.wager * game.count;
        if (game.token == address(0)) {
            // If the token is Ether
            treasury.deposit{value: totalWager}(totalWager);
        } else {
            // If the token is an ERC20 token
            IERC20 tokenContract = IERC20(game.token);
            tokenContract.approve(address(treasury), totalWager);
            treasury.transferFrom(game.token, address(this), address(treasury), totalWager);
        }

        // Emit events and notify the treasury contract about the game result
        emit GameResult(game.player, totalRefund, flags.initialRandomNumber, flags.wonCount, flags.playedCount, game.token);
        treasury.notifyGameResult(sequenceNumber, totalRefund, flags.initialRandomNumber, flags.wonCount, flags.playedCount, 0);
        // delete games[sequenceNumber];
    }

    /// @dev Determines the multiplier based on the slot symbols.
    /// @param symbols The slot symbols
    /// @return The multiplier for the payout
    function getMultiplier(Symbols memory symbols) internal pure returns (uint256) {
        // Check combinations for the multiplier
        if (symbols.symbol1 == 0 && symbols.symbol2 == 0 && symbols.symbol3 == 0) //1
            return 27;
        if (symbols.symbol1 == 1 && symbols.symbol2 == 1 && symbols.symbol3 == 0)  //1
            return 22;
        if (symbols.symbol1 == 1 && symbols.symbol2 == 1 && symbols.symbol3 == 1) //1
            return 18;
        if (symbols.symbol1 == 2 && symbols.symbol2 == 2) //7
            return 9;
        if (symbols.symbol1 == 3 && symbols.symbol2 == 3) //7
            return 6;
        if (symbols.symbol1 == 4 && symbols.symbol2 == 4) //7
            return 6;
        if (symbols.symbol1 == 5 && symbols.symbol2 == 5) //7
            return 3;
        if (symbols.symbol1 == 6 && symbols.symbol2 == 6) //7
            return 2;
        if (symbols.symbol1 == 0 && symbols.symbol2 != 0 && symbols.symbol3 == 0) //6
            return 1;
        if (symbols.symbol1 != 0 && symbols.symbol2 == 0 && symbols.symbol3 == 0) //6
            return 1;
        if (symbols.symbol1 == 1 && symbols.symbol2 != 1 && symbols.symbol3 == 1) //6
            return 1;
        if (symbols.symbol1 != 1 && symbols.symbol2 == 1 && symbols.symbol3 == 1) //6
            return 1;
        return 0;
    }

}
